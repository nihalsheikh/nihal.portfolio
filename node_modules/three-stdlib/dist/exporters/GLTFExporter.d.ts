import { Scene, Object3D, AnimationClip, Material, Texture, Camera, KeyframeTrack, Light, Vector2Tuple, Vector3Tuple } from 'three';
export interface GLTFExporterOptions {
    binary?: boolean;
    trs?: boolean;
    onlyVisible?: boolean;
    truncateDrawRange?: boolean;
    embedImages?: boolean;
    animations?: AnimationClip[];
    forceIndices?: boolean;
    forcePowerOfTwoTextures?: boolean;
    includeCustomExtensions?: boolean;
}
declare type PluginCallback = (writer: GLTFWriter) => GLTFLightExtension | GLTFMaterialsUnlitExtension | GLTFMaterialsPBRSpecularGlossiness | GLTFMaterialsTransmissionExtension | GLTFMaterialsVolumeExtension;
declare type TransformDef = {
    offset?: Vector2Tuple;
    rotation?: number;
    scale?: Vector2Tuple;
};
declare type BufferViewDef = {
    buffer: number;
    byteOffset: number;
    byteLength: number;
    target?: number;
    byteStride?: number;
};
declare type AccessorDef = {
    bufferView: unknown;
    byteOffset: unknown;
    componentType: unknown;
    count: unknown;
    max: unknown;
    min: unknown;
    type: unknown;
    normalized?: boolean;
};
declare type ImageDef = {
    mimeType: string;
    bufferView?: number;
    uri?: string;
};
declare type ImageRepresentation = HTMLImageElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap;
declare type SamplerDef = {
    magFilter: typeof WEBGL_CONSTANTS[keyof typeof WEBGL_CONSTANTS];
    minFilter: typeof WEBGL_CONSTANTS[keyof typeof WEBGL_CONSTANTS];
    wrapS: typeof WEBGL_CONSTANTS[keyof typeof WEBGL_CONSTANTS];
    wrapT: typeof WEBGL_CONSTANTS[keyof typeof WEBGL_CONSTANTS];
};
declare type TextureDef = {
    sampler: number;
    source: number;
    name?: string;
};
declare type MaterialDef = {
    pbrMetallicRoughness: {
        baseColorFactor?: number[];
        metallicFactor?: number;
        roughnessFactor?: number;
        metallicRoughnessTexture?: {
            index: number;
        };
        baseColorTexture?: {
            index: number;
        };
    };
    emissiveFactor?: number[];
    emissiveTexture?: {
        index: number;
    };
    normalTexture?: {
        index: number;
        scale?: number | undefined;
    };
    occlusionTexture?: OcclusionMapDef;
    alphaMode?: string;
    alphaCutoff?: number;
    doubleSided?: boolean;
    name?: string;
    extensions?: {
        [key: string]: unknown;
    };
};
declare type OcclusionMapDef = {
    index: number;
    texCoord: number;
    strength?: number;
};
declare type CameraDef = {
    type: string;
    orthographic?: {
        xmag: number;
        ymag: number;
        zfar: number;
        znear: number;
    };
    perspective?: {
        aspectRatio: number;
        yfov: number;
        zfar: number;
        znear: number;
    };
    name?: string;
};
declare type NodeDef = {
    rotation?: number[];
    translation?: Vector3Tuple;
    scale?: Vector3Tuple;
    matrix?: number[];
    name?: string;
    mesh?: number;
    camera?: number;
    children?: number[];
    extensions?: {
        [key: string]: number | {
            light?: number;
        };
    };
};
declare type SceneDef = {
    name?: string;
    nodes?: number[];
};
declare class GLTFExporter {
    private pluginCallbacks;
    constructor();
    private register;
    unregister(callback: PluginCallback): this;
    parse(input: Object3D, onDone: (gltf: object) => void, options: GLTFExporterOptions): void;
    /**
     * Static utility functions
     */
    static Utils: {
        insertKeyframe: (track: KeyframeTrack, time: number) => number | undefined;
        mergeMorphTargetTracks: (clip: AnimationClip, root: any) => AnimationClip;
    };
}
declare const WEBGL_CONSTANTS: {
    readonly POINTS: 0;
    readonly LINES: 1;
    readonly LINE_LOOP: 2;
    readonly LINE_STRIP: 3;
    readonly TRIANGLES: 4;
    readonly TRIANGLE_STRIP: 5;
    readonly TRIANGLE_FAN: 6;
    readonly UNSIGNED_BYTE: 5121;
    readonly UNSIGNED_SHORT: 5123;
    readonly FLOAT: 5126;
    readonly UNSIGNED_INT: 5125;
    readonly ARRAY_BUFFER: 34962;
    readonly ELEMENT_ARRAY_BUFFER: 34963;
    readonly NEAREST: 9728;
    readonly LINEAR: 9729;
    readonly NEAREST_MIPMAP_NEAREST: 9984;
    readonly LINEAR_MIPMAP_NEAREST: 9985;
    readonly NEAREST_MIPMAP_LINEAR: 9986;
    readonly LINEAR_MIPMAP_LINEAR: 9987;
    readonly CLAMP_TO_EDGE: 33071;
    readonly MIRRORED_REPEAT: 33648;
    readonly REPEAT: 10497;
};
/**
 * Writer
 */
declare class GLTFWriter {
    private plugins;
    private options;
    private pending;
    private buffers;
    private byteOffset;
    private nodeMap;
    private skins;
    extensionsUsed: {
        [key: string]: boolean;
    };
    private uids;
    private uid;
    json: {
        asset: {
            version: string;
            generator: string;
        };
        buffers?: {
            uri?: ArrayBuffer | string;
            byteLength: number;
        }[];
        extensionsUsed?: string[];
        bufferViews?: BufferViewDef[];
        images?: ImageRepresentation[] & ImageDef[];
        accessors?: AccessorDef[];
        samplers?: SamplerDef[];
        textures?: Texture[] & TextureDef[];
        materials?: Material[] & MaterialDef[];
        meshes?: unknown[];
        cameras?: (Camera | CameraDef)[];
        animations?: unknown[];
        nodes?: {
            [key: string]: unknown;
        }[];
        skins?: {}[];
        scenes?: (Scene | SceneDef)[];
        scene?: number;
        extensions?: {
            [key: string]: {
                lights: unknown[];
            };
        };
    };
    private cache;
    private cachedCanvas;
    constructor();
    setPlugins(plugins: ReturnType<PluginCallback>[]): void;
    /**
     * Parse scenes and generate GLTF output
     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
     * @param  {Function} onDone  Callback on completed
     * @param  {Object} options options
     */
    write(input: Object3D, onDone: (gltf: object) => void, options: GLTFExporterOptions): void;
    /**
     * Serializes a userData.
     *
     * @param {THREE.Object3D|THREE.Material} object
     * @param {Object} objectDef
     */
    private serializeUserData;
    /**
     * Assign and return a temporal unique id for an object
     * especially which doesn't have .uuid
     * @param  {Object} object
     * @return {Integer}
     */
    private getUID;
    /**
     * Checks if normal attribute values are normalized.
     *
     * @param {BufferAttribute} normal
     * @returns {Boolean}
     */
    private isNormalizedNormalAttribute;
    /**
     * Creates normalized normal buffer attribute.
     *
     * @param {BufferAttribute} normal
     * @returns {BufferAttribute}
     *
     */
    private createNormalizedNormalAttribute;
    /**
     * Applies a texture transform, if present, to the map definition. Requires
     * the KHR_texture_transform extension.
     *
     * @param {Object} mapDef
     * @param {THREE.Texture} texture
     */
    applyTextureTransform(mapDef: {
        extensions?: {
            [key: string]: TransformDef;
        };
        index?: number;
    }, texture: Texture): void;
    /**
     * Process a buffer to append to the default one.
     * @param  {ArrayBuffer} buffer
     * @return {Integer}
     */
    processBuffer(buffer: ArrayBuffer): number;
    /**
     * Process and generate a BufferView
     * @param  {BufferAttribute} attribute
     * @param  {number} componentType
     * @param  {number} start
     * @param  {number} count
     * @param  {number} target (Optional) Target usage of the BufferView
     * @return {Object}
     */
    private processBufferView;
    /**
     * Process and generate a BufferView from an image Blob.
     * @param {Blob} blob
     * @return {Promise<Integer>}
     */
    processBufferViewImage(blob: Blob): Promise<number>;
    /**
     * Process attribute to generate an accessor
     * @param  {BufferAttribute} attribute Attribute to process
     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
     * @param  {Integer} start (Optional)
     * @param  {Integer} count (Optional)
     * @return {Integer|null} Index of the processed accessor on the "accessors" array
     */
    private processAccessor;
    /**
     * Process image
     * @param  {Image} image to process
     * @param  {Integer} format of the image (RGBAFormat)
     * @param  {Boolean} flipY before writing out the image
     * @return {Integer}     Index of the processed texture in the "images" array
     */
    private processImage;
    /**
     * Process sampler
     * @param  {Texture} map Texture to process
     * @return {Integer}     Index of the processed texture in the "samplers" array
     */
    private processSampler;
    /**
     * Process texture
     * @param  {Texture} map Map to process
     * @return {Integer} Index of the processed texture in the "textures" array
     */
    processTexture(map: Texture): number;
    /**
     * Process material
     * @param  {THREE.Material} material Material to process
     * @return {Integer|null} Index of the processed material in the "materials" array
     */
    private processMaterial;
    /**
     * Process mesh
     * @param  {THREE.Mesh} mesh Mesh to process
     * @return {Integer|null} Index of the processed mesh in the "meshes" array
     */
    private processMesh;
    /**
     * Process camera
     * @param  {THREE.Camera} camera Camera to process
     * @return {Integer}      Index of the processed mesh in the "camera" array
     */
    private processCamera;
    /**
     * Creates glTF animation entry from AnimationClip object.
     *
     * Status:
     * - Only properties listed in PATH_PROPERTIES may be animated.
     *
     * @param {THREE.AnimationClip} clip
     * @param {THREE.Object3D} root
     * @return {number|null}
     */
    private processAnimation;
    /**
     * @param {THREE.Object3D} object
     * @return {number|null}
     */
    private processSkin;
    /**
     * Process Object3D node
     * @param  {THREE.Object3D} node Object3D to processNode
     * @return {Integer} Index of the node in the nodes list
     */
    private processNode;
    /**
     * Process Scene
     * @param  {Scene} node Scene to process
     */
    private processScene;
    private processObjects;
    /**
     * @param {THREE.Object3D|Array<THREE.Object3D>} input
     */
    private processInput;
    private _invokeAll;
    /**
     * Compare two arrays
     * @param  {Array} array1 Array 1 to compare
     * @param  {Array} array2 Array 2 to compare
     * @return {Boolean}        Returns true if both arrays are equal
     */
    private equalArray;
    /**
     * Converts a string to an ArrayBuffer.
     * @param  {string} text
     * @return {ArrayBuffer}
     */
    private stringToArrayBuffer;
    private isIdentityMatrix;
    private getMinMax;
    /**
     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
     */
    private getPaddedBufferSize;
    /**
     * Returns a buffer aligned to 4-byte boundary.
     *
     * @param {ArrayBuffer} arrayBuffer Buffer to pad
     * @param {Integer} paddingByte (Optional)
     * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
     */
    private getPaddedArrayBuffer;
}
/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
declare class GLTFLightExtension {
    private writer;
    private name;
    constructor(writer: GLTFWriter);
    writeNode(light: Light, nodeDef: NodeDef): void;
}
/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
declare class GLTFMaterialsUnlitExtension {
    private writer;
    private name;
    constructor(writer: GLTFWriter);
    writeMaterial(material: Material, materialDef: MaterialDef): void;
}
/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */
declare class GLTFMaterialsPBRSpecularGlossiness {
    private writer;
    private name;
    constructor(writer: GLTFWriter);
    writeMaterial(material: Material, materialDef: MaterialDef): void;
}
/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 */
declare class GLTFMaterialsTransmissionExtension {
    private writer;
    private name;
    constructor(writer: GLTFWriter);
    writeMaterial(material: Material, materialDef: MaterialDef): void;
}
/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
declare class GLTFMaterialsVolumeExtension {
    private writer;
    private name;
    constructor(writer: GLTFWriter);
    writeMaterial(material: Material, materialDef: MaterialDef): void;
}
export { GLTFExporter };
